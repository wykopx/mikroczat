"use strict"; import *as api from "./wykop_api.js"; import *as CONST from "./const.js"; import *as T from "./types.js"; import *as fn from "./fn.js"; export let dev = !1; "chat" == $folder && (dev = !0); const openedChannels = new Map, activeChannels = [null, null]; export let settings = { channelStatistics: !1, highlightQuick: !1, highlightLock: !0, newMessageSendButton: !0, rightClickOnUsernameCopiesToClipboard: !0, rightClickOnUsernameShowContextMenu: !1, rightClickOnUsernameInsertsToNewMessage: !0, leftClickOnUsernameInsertsToNewMessage: !0, leftClickCTRLOnUsernameInsertsToNewMessage: !0, leftClickALTOnUsernameInsertsToNewMessage: !0, leftClickSHIFTOnUsernameInsertsToNewMessage: !0, leftClickOnYouTubeLoadsToIframe: !0, promoFooter: { emoji: !0, label: !0, roomInfo: !1, mikroczatLinks: !1 }, editorSendHotkey: { enter: !1, ctrl_enter: !0, ctrl_s: !0 }, fetch: { numbersOfEntriesToLoadOnChannelOpen: 5, numbersOfEntriesToLoadInChannel: 50, numbersOfCommentsToLoad: 50 }, usersList: { showOfflineUsers: !0, sortAlphabetically: !0 }, sounds: { incoming_entry: { enabled: !1, file: "iphone-message-received.mp3" }, incoming_comment: { enabled: !1, file: "iphone-message-received.mp3" }, incoming_mention: { enabled: !0, file: "iphone-message-received.mp3" }, incoming_pm: { enabled: !0, file: "iphone-message-received.mp3" }, outgoing_entry: { enabled: !0, file: "iphone-message-sent.mp3" }, outgoing_comment: { enabled: !0, file: "iphone-message-sent.mp3" }, outgoing_pm: { enabled: !0, file: "iphone-message-sent.mp3" }, logged_in: { enabled: !0, file: "tiktok.mp3" }, logged_out: { enabled: !0, file: "mirkoczat.mp3" } }, tabTitle: { unreadMessagesBadge: { enabled: !1, icon: "ðŸ•­", showIcon: !0, showCount: !0 }, unreadMentionsBadge: { enabled: !0, icon: "ðŸ””", showIcon: !0, showCount: !0 } }, refreshIntervals: { allEntriesAndComments: 15e3, timeoutForEntriesPagesOver50: 500, timeoutForCommentsOver50: 500 }, css: { chatArea: { plusButtonShow: !1, scrollSnap: !1 } } }; dev && (settings.channelStatistics = !0, settings.highlightQuick = !0, settings.sounds.incoming_entry.enabled = !1, settings.sounds.incoming_comment.enabled = !1, settings.tabTitle.unreadMessagesBadge.enabled = !0); const sounds = { logged_in: new Audio(`/_sounds/${settings.sounds.logged_in.file}`), logged_out: new Audio(`/_sounds/${settings.sounds.logged_out.file}`), outgoing_entry: new Audio(`/_sounds/${settings.sounds.outgoing_entry.file}`), outgoing_comment: new Audio(`/_sounds/${settings.sounds.outgoing_comment.file}`), incoming_entry: new Audio(`/_sounds/${settings.sounds.incoming_entry.file}`), incoming_comment: new Audio(`/_sounds/${settings.sounds.incoming_comment.file}`), incoming_mention: new Audio(`/_sounds/${settings.sounds.incoming_mention.file}`) }; let nightMode = localStorage.getItem("nightMode"), mikroczatLoggedIn = !1, wykopDomain = "https://wykop.pl", wxDomain = "https://wykopx.pl", mikroczatDomain = "https://mikroczat.pl"; const root = document.documentElement, head = document.head, body = document.body, main = document.getElementById("main"), centerHeader = document.getElementById("centerHeader"), template_channelFeed = document.getElementById("template_channelFeed"), template_usersList = document.getElementById("template_usersList"), template_messageArticle = document.getElementById("template_messageArticle"), template_userListItem = document.getElementById("template_userListItem"), chatArea = document.getElementById("chatArea"), mikrochatFeeds = document.getElementById("mikrochatFeeds"), usersPanel = document.getElementById("usersPanel"), youtubeIframe = document.getElementById("youtubeIframe"); export let user = new T.User("Anonim"); export let tokensObject = api.getTokenFromDatabase(); !tokensObject.token && !tokensObject.refresh_token || mikroczatLoggedIn || logIn(); const chooseChannelDialog = document.querySelector("#chooseChannelDialog"), loginDialog = document.querySelector("#loginDialog"), loginInput = document.querySelector("#loginInput"), loginAlertTokenSuccess = document.querySelector("#loginDialog #loggedInToken"), loginAlertRefreshTokenSuccess = document.querySelector("#loginDialog #loggedInRefreshToken"), loginAlertError = document.querySelector("#loginDialog .alert-error"), showLoginDialogButton = document.querySelector("#showLoginDialog"), closeLoginDialogButton = document.querySelector("#closeLoginDialogButton"); function processLoginData(e) { if ("" == e || null == e || null == e) return !1; if (e.length < 64) return fn.hide(loginAlertRefreshTokenSuccess), fn.hide(loginAlertTokenSuccess), fn.show(loginAlertError), !1; let t = api.saveToken({ tokenValue: e }); return !1 === t ? (fn.hide(loginAlertRefreshTokenSuccess), fn.hide(loginAlertTokenSuccess), fn.show(loginAlertError), !1) : (fn.hide(loginAlertError), "refreshToken" in t ? (fn.show(loginAlertRefreshTokenSuccess), !0) : "token" in t ? (fn.show(loginAlertTokenSuccess), !0) : void 0) } async function logIn() { if (tokensObject.refresh_token) { let e = await api.fetchAPIrefreshTokens(); !1 !== e && "object" == typeof e && "token" in e && (tokensObject.token = e.token) } tokensObject.token || (tokensObject = api.getTokenFromDatabase()), mikroczatLoggedIn || await api.fetchAPIrefreshTokens(), await fetch(`${CONST.apiPrefixURL}/profile/short`, { method: "GET", headers: { "Content-Type": "application/json", Authorization: "Bearer " + window.localStorage.getItem("token") } }).then((async e => e.ok ? e.json() : (mikroczatLoggedIn = !1, await api.fetchAPIrefreshTokens(), !1))).then((e => (user = e.data, window.localStorage.setItem("username", user.username), confirmLoggedIn(), !0))).catch((e => { mikroczatLoggedIn = !1, loginDialog.showModal(), TypeError })) } async function confirmLoggedIn() { if (mikroczatLoggedIn = !0, fn.innerHTML(".loggedInUsername", user.username), loginDialog.close(), settings.sounds.logged_in && navigator?.userActivation?.hasBeenActive && sounds.logged_in.play(), document.getElementById("showLoginDialog").classList.add("hidden"), document.getElementById("logOutButton").classList.remove("hidden"), document.querySelectorAll("a.loggedInHref").forEach((e => { e.href = "https://go.wykopx.pl/@${user.username}", e.classList.add(`${user.status}`, `${user.color}-profile`, `${user.gender}-gender`) })), window.opener && window.opener.postMessage("mikroczatLoggedInIn", wykopDomain), openChannelsFromURLArray.length > 0) for (const e of openChannelsFromURLArray) { const t = new T.Tag(e), n = new T.Channel(t); openedChannels.set(e, n) } if (openedChannels.size > 0) for (let [, e] of openedChannels) openNewChannel(e), await new Promise((e => setTimeout(e, 1e3))), window.activateChannel(e), await new Promise((e => setTimeout(e, 4e3))) } async function addUserToChannel(e, ...t) { t.forEach((async t => { "string" == typeof t && e.users.has(t), t instanceof T.User && !e.users.has(t.username) && (e.users.set(t.username, t), settings.channelStatistics && (document.getElementById(`${e.name}_usersCount`).innerText = String(e.users.size)), (t.online || settings.usersList.showOfflineUsers) && (e.elements.usersListContainer.append(await getUserHTMLElement(t, e)), settings.channelStatistics && (document.getElementById(`${e.name}_usersOnlineCount`).innerText = String(getNumberOfOnlineUsersOnChannel(e))))) })) } function getNumberOfOnlineUsersOnChannel(e) { return Array.from(e.users.values()).filter((e => e.online)).length } async function openNewChannel(e) { await e.tag.initFromAPI().then((() => { openedChannels.set(e.name, e) })); const t = template_channelFeed.content.cloneNode(!0), n = t.querySelector(".channelFeed"), s = t.querySelector(".newMessageTextarea"), a = t.querySelector(".newMessageSendButton"), o = t.querySelector(".channelStatistics"); n && (n.dataset.channel = e.name, n.id = `channel_${e.name}`, s.dataset.channel = e.name, a.dataset.channel = e.name, 0 == settings.newMessageSendButton && a.classList.add("hidden"), o && (o.dataset.channel = e.name, o.querySelector("#channel_usersCount").id = `${e.name}_usersCount`, o.querySelector("#channel_usersOnlineCount").id = `${e.name}_usersOnlineCount`, o.querySelector("#channel_entriesCount").id = `${e.name}_entriesCount`, o.querySelector("#channel_messagesCount").id = `${e.name}_messagesCount`, o.querySelector("#channel_plusesCount").id = `${e.name}_plusesCount`, o.querySelector("#channel_timespan").id = `${e.name}_timespan`, 0 == settings.channelStatistics && o.classList.add("hidden")), mikrochatFeeds.appendChild(t)); const r = template_usersList.content.cloneNode(!0), i = r.querySelector(".usersList"); return i && (i.dataset.channel = e.name, i.id = `channel_users_${e.name}`), openedChannels.get(e.name).elements.channelFeed = document.getElementById(`channel_${e.name}`), openedChannels.get(e.name).elements.channelFeed && (openedChannels.get(e.name).elements.messagesContainer = openedChannels.get(e.name).elements.channelFeed.querySelector(".messagesContainer"), openedChannels.get(e.name).elements.newMessageTextarea = openedChannels.get(e.name).elements.channelFeed.querySelector(".newMessageTextarea")), usersPanel.appendChild(r), openedChannels.get(e.name).elements.usersListContainer = usersPanel.querySelector(".usersListContainer"), addUserToChannel(e, user), await checkAndInsertNewEntriesInChannel(e, settings.fetch.numbersOfEntriesToLoadOnChannelOpen).then((() => { e.loadingStatus = "preloaded" })), e.entries.size > 0 && await checkAndInsertNewCommentsInChannel(e).then((() => { e.loadingStatus = "preloaded" })), mikrochatFeeds.querySelector(".loadingInfo").classList.add("hidden"), setupScrollListener(openedChannels.get(e.name).elements.messagesContainer), await fetchOpenedChannelsDataFirstPreload(e).then((async () => { e.loadingStatus = "preloaded", await fetchOpenedChannelsData(e) })), e } async function fetchOpenedChannelsDataFirstPreload(e) { let t = []; if (e.entries.size <= settings.fetch.numbersOfEntriesToLoadOnChannelOpen && (t = await checkAndInsertNewEntriesInChannel(e, settings.fetch.numbersOfEntriesToLoadInChannel)), t.length > 0) for (let n of t) n.comments.count > 0 && await checkAndInsertNewCommentsInEntry(e, n) } async function fetchOpenedChannelsData(e) { for (e.elements.channelFeed.dataset.loaded = "true", e.loadingStatus = "loaded"; ;)await new Promise((e => setTimeout(e, settings.refreshIntervals.allEntriesAndComments))), await refreshAllEntriesCommentsCountAndVotesUpInChannel(e) } async function refreshAllEntriesCommentsCountAndVotesUpInChannel(e) { const t = await api.getXNewestEntriesFromChannel(e, e.entries.size, settings.refreshIntervals.timeoutForEntriesPagesOver50); return t.length > 0 && analyzeMessagesArrayAddNewItemsOrUpdateDataExistingMessages(e, t), !0 } function analyzeMessagesArrayAddNewItemsOrUpdateDataExistingMessages(e, t) { for (const n of t) e.entries.has(n.id) ? (n.comments?.count && n.comments.count != e.entries.get(n.id).comments.count && (e.entries.get(n.id).comments.count = n.comments.count), n.votes?.up && n.votes.up != e.entries.get(n.id).votes.up && (e.entries.get(n.id).votes.up = n.votes.up, settings.channelStatistics && (document.getElementById(`${e.name}_plusesCount`).innerText = String([...e.entries.values(), ...e.comments.values()].reduce(((e, t) => e + t.votes.up), 0)))), n.voted && n.voted != e.entries.get(n.id).voted && (e.entries.get(n.id).voted = n.voted)) : insertNewItem(e, n) } showLoginDialogButton && showLoginDialogButton.addEventListener("click", (() => { loginDialog.showModal() })), closeLoginDialogButton && closeLoginDialogButton.addEventListener("click", (() => { processLoginData(loginInput.value) && logIn(), loginDialog.close() })), loginInput && (loginInput.addEventListener("paste", (e => { processLoginData(e.target.value) })), loginInput.addEventListener("change", (e => { processLoginData(e.target.value) })), loginInput.addEventListener("input", (e => { processLoginData(e.target.value) }))); export function updateCSSPropertyOnMessageArticleElement(e, t, n) { let s = null; ("entry" === e.resource || "entry_comment" === e.resource) && (s = mikrochatFeeds.querySelector(`.messageArticle[data-id="${e.id}"]`)), s && (n ? ("up" === t && (s.style.setProperty("--votesUp", `"${n.up}"`), s.dataset.votesUp = n.up), "entry" === e.resource && "count" === t && (s.style.setProperty("--commentsCount", `"${n.count}"`), s.dataset.commentsCount = n.count), "voted" === t && (s.dataset.voted = n.voted)) : e && (s.style.setProperty("--votesUp", `"${e.votes.up}"`), s.dataset.votesUp = e.votes.up, "entry" === e.resource && s.style.setProperty("--commentsCount", `"${e.comments.count}"`), s.dataset.commentsCount = e.comments.count, s.dataset.voted = e.voted)) } async function checkAndInsertNewEntriesInChannel(e, t = settings.fetch.numbersOfEntriesToLoadInChannel) { const n = (await api.getXNewestEntriesFromChannel(e, t, settings.refreshIntervals.timeoutForEntriesPagesOver50)).filter((t => !e.entries.has(t.id))); return n.length > 0 && insertNewItemsFromArray(e, n), n } function insertNewItemsFromArray(e, t) { for (const n of t) insertNewItem(e, n) } function insertNewItem(e, t) { t.id && (addUserToChannel(e, t.author), insertNewMessage(e, t)) } async function checkAndInsertNewCommentsInChannel(e) { for (const [t, n] of e.entries) if (n?.comments?.count > 0 && n.comments.count > n.last_checked_comments_count) { const t = (await api.getAllCommentsFromEntry(n, settings.refreshIntervals.timeoutForCommentsOver50)).filter((t => !e.comments.has(t.id))); t.length > 0 && insertNewItemsFromArray(e, t) } } export async function checkAndInsertNewCommentsInEntry(e, t) { if (t.comments.count > 0) { const n = (await api.getAllCommentsFromEntry(t, settings.refreshIntervals.timeoutForCommentsOver50)).filter((t => !e.comments.has(t.id))); if (n.length > 0) for (const t of n) addUserToChannel(e, t.author), insertNewMessage(e, t) } } async function setCheckingForNewMessagesInChannel(e, t = 36e3) { } async function insertNewMessage(e, t) { const n = openedChannels.get(e.name); return ("entry" !== t.resource || !n.entries.has(t.id)) && (("entry_comment" !== t.resource || !n.comments.has(t.id)) && (n.elements.messagesContainer.append(await getMessageHTMLElement(t)), n.addEntryOrCommentToChannelObject(e, t), "1" == n.elements.messagesContainer.dataset.scrollToNew && (n.elements.messagesContainer.scrollTop = n.elements.messagesContainer.scrollHeight), navigator?.userActivation?.hasBeenActive && t.created_at_SecondsAgo < 120 && (t.author.username == user.username ? "entry" === t.resource && settings.sounds.outgoing_entry.enabled ? sounds.outgoing_entry.play() : "entry_comment" === t.resource && settings.sounds.outgoing_comment.enabled && sounds.outgoing_comment.play() : ("entry" === t.resource && settings.sounds.incoming_entry.enabled && sounds.incoming_entry.play(), "entry_comment" === t.resource && settings.sounds.incoming_comment.enabled && sounds.incoming_comment.play())), "visible" != document.visibilityState && "loaded" == e.loadingStatus && (e.unreadMessagesCount++, t.isMentioningUser(user.username) && e.unreadMentionsCount++, settings.tabTitle.unreadMessagesBadge.enabled, settings.tabTitle.unreadMentionsBadge.enabled && (window.top.document.title = getTabTitle(e))), void document.visibilityState)) } function getTabTitle(e) { let t = ""; return settings.tabTitle.unreadMentionsBadge.enabled && e.unreadMentionsCount > 0 ? (settings.tabTitle.unreadMentionsBadge.showIcon && (t += `${settings.tabTitle.unreadMentionsBadge.icon} `), settings.tabTitle.unreadMentionsBadge.showCount ? (t += "(", t += e.unreadMentionsCount, settings.tabTitle.unreadMessagesBadge.enabled && settings.tabTitle.unreadMessagesBadge.showCount && (t += `/${e.unreadMessagesCount}`), t += ") ") : settings.tabTitle.unreadMessagesBadge.showCount && (t += `(${e.unreadMessagesCount}) `)) : settings.tabTitle.unreadMessagesBadge.enabled && e.unreadMessagesCount > 0 && (settings.tabTitle.unreadMessagesBadge.showIcon && (t += `${settings.tabTitle.unreadMessagesBadge.icon} `), settings.tabTitle.unreadMessagesBadge.showCount && (t += `(${e.unreadMessagesCount}) `)), t += `${e.name} ${CONST.tabTitleTemplate}`, t } async function getMessageHTMLElement(e) { const t = template_messageArticle.content.cloneNode(!0), n = t.querySelector(".messageArticle"), s = t.querySelector(".permalinkHref"), a = t.querySelector("a.username"), o = t.querySelector(".username_span"), r = t.querySelector(".messageContent"), i = t.querySelector(".entryImage"), l = t.querySelector(".entryImageHref"), d = t.querySelector(".entryMediaEmbedYouTube"), c = t.querySelector(".entryMediaEmbedStreamable"), u = t.querySelector(".entryMediaEmbedTwitter"), m = t.querySelector(".entryDate"), g = t.querySelector(".entryDateYYYMMDD"), h = t.querySelector(".entryDateHHMM"), p = t.querySelector(".entryDateHHMMSS"); if (n.id = `${e.resource}-${String(e.id)}`, n.dataset.id = String(e.id), n.dataset.entryId = String(e.entry_id), n.dataset.authorUsername = e.author?.username, n.style.order = `-${e.created_at_Timestamp}`, e.author?.username === user.username && n.classList.add("own"), e.author?.username === e.channel?.tag?.author?.username && n.classList.add("channelOwner"), e.isMentioningUser(user.username) && n.classList.add("isMentioningYou"), m.title = `${e.created_at_Format("eeee BBBB")} | ${e.created_at_FormatDistanceSuffix} \n${e.created_at_Format("yyyy-MM-dd 'o godz.' HH:mm ")}`, g.textContent = e.created_at_Format("yyyy-MM-dd"), h.textContent = e.created_at_Format("HH:mm"), p.textContent = e.created_at_Format("HH:mm:ss"), n.style.setProperty("--votesUp", `"${e.votes.up}"`), n.dataset.votesUp = `${e.votes.up}`, n.dataset.voted = `${e.voted}`, "entry" === e.resource ? (n.classList.add("entry"), s.setAttribute("href", `https://go.wykopx.pl/w${e.entry_id}`), n.dataset.commentsCount = `${e.comments.count}`, n.style.setProperty("--commentsCount", `"${e.comments.count}"`)) : "entry_comment" === e.resource && (n.classList.add("comment", "reply"), s.setAttribute("href", `https://go.wykopx.pl/w${e.entry_id}k${e.id}`)), e.author.avatar) { t.querySelector(".avatar_img").setAttribute("src", e.author.avatar) } if (a.setAttribute("href", `https://go.wykopx.pl/@${e.author.username}`), a.dataset.username = e.author.username, a.dataset.channel = e.channel.name, n.classList.add(e.author?.status), a.classList.add(e.author?.status), o.textContent = e.author.username, e.author?.color?.name && (n.classList.add(`${e.author?.color?.name}-profile`), a.classList.add(`${e.author?.color?.name}-profile`)), "m" == e.author?.gender ? (n.classList.add("male", "m-gender"), a.classList.add("male", "m-gender")) : "f" == e.author?.gender ? (n.classList.add("female", "f-gender"), a.classList.add("female", "f-gender")) : (n.classList.add("null-gender"), a.classList.add("null-gender")), e.media?.photo?.url && (i.src = e.media.photo.url, l.href = e.media.photo.url), e.media?.embed?.url && e.media?.embed?.type) if ("youtube" === e.media?.embed?.type) { d.href = e.media.embed.url; let t = fn.getEmbedVideoIDCodeFromYouTubeURL(e.media.embed.url); t && "string" == typeof t && (n.dataset.youtube = t) } else "streamable" === e.media?.embed?.type ? c.href = e.media.embed.url : "twitter" === e.media?.embed?.type && (u.href = e.media.embed.url); return e.deleted ? (n.dataset.deleted = "1", r.innerHTML = "(wiadomoÅ›Ä‡ usuniÄ™ta)") : (e.content.includes("](https://mikroczat.pl/czat/") ? n.dataset.device = "Mikroczat" : "" != n.dataset.device && (n.dataset.device = e.device), r.innerHTML = e.content_parsed()), t } async function getUserHTMLElement(e, t) { const n = template_userListItem.content.cloneNode(!0), s = n.querySelector(".userListItem"), a = n.querySelector(".avatar_img"), o = n.querySelector("a.username"), r = n.querySelector(".username_span"); e.avatar && a.setAttribute("src", e.avatar), o.setAttribute("href", `https://go.wykopx.pl/@${e.username}`), o.dataset.username = e.username, o.dataset.channel = t.name, r.textContent = e.username; let i = 0; return settings.usersList.sortAlphabetically && (i = e.numericalOrder), e.color?.name && (s.classList.add(`${e.color?.name}-profile`), o.classList.add(`${e.color?.name}-profile`)), "m" == e.gender ? (s.classList.add("male", "m-gender"), o.classList.add("male", "m-gender")) : "f" == e.gender ? (s.classList.add("female", "f-gender"), o.classList.add("female", "f-gender")) : (s.classList.add("null-gender"), o.classList.add("null-gender")), e.company && s.classList.add("company"), e.verified && s.classList.add("verified"), e.blacklist && s.classList.add("blacklist"), e.follow && s.classList.add("follow"), e.note && s.classList.add("note"), e.online && (s.classList.add("online"), i -= 2e6), e.followers && (s.dataset.followers = String(e.followers)), e.member_since && (s.dataset.memberSince = String(e.member_since)), e.name && (s.dataset.name = e.name), e.rank?.position && (s.dataset.rankPosition = String(e.rank.position), s.dataset.rankTrend = String(e.rank.trend)), s.classList.add(e.status), s.dataset.status = e.status, o.classList.add(e.status), "removed" === e.status ? i = 5e6 : "banned" === e.status ? i = 4e6 : "suspended" === e.status && (i = 3e6), (e.channel && e.username === e.channel?.tag?.author?.username || t && e.username === t?.tag?.author?.username) && (s.classList.add("channelOwner"), i -= 3e6), e.username === user.username && (s.classList.add("own"), i = -4e6), s.style.order = String(i), n } function toggleNightMode(e = !0) { "1" == e || 1 == e ? e = !0 : "0" != e && 0 != e || (e = !1), 0 == e || "1" == body.dataset.nightMode ? (body.dataset.nightMode = "0", nightMode = "0") : (body.dataset.nightMode = "1", nightMode = "1"), localStorage.setItem("nightMode", nightMode) } function mouseOutAddEventListenerRemoveHighlightQuick(e) { e.addEventListener("mouseout", (function (t) { e.classList.remove("highlightQuick"), unhighlight(".messageArticle.highlightQuick", "highlightQuick") })) } function getMergedSortedFromOldestArrayOfMessages(e) { return [...Array.from(e.entries.values()), ...Array.from(e.comments.values())].sort(((e, t) => e.created_at_Timestamp - t.created_at_Timestamp)) } function getMergedSortedFromOldestArrayOfMessagesByUsername(e, t) { return [...Array.from(e.entries.values()), ...Array.from(e.comments.values())].sort(((e, t) => e.created_at_Timestamp - t.created_at_Timestamp)).filter((e => e.author.username === t)) } function getNewestMessageOfUser(e, t) { return getMergedSortedFromOldestArrayOfMessagesByUsername(e, t).pop() } function getUsernamesArrayFromText(e, t = !0) { const n = /(\B)@([\w-_]+):?/g, s = []; let a; for (; null !== (a = n.exec(e));)t && a[0].startsWith("@") ? s.push(a[0].slice(1)) : s.push(a[0]); return s } function prepareNewMessageBody(e, t) { let n = fn.getPrefixedFlagsArray(t.content); if (2 == n.length && fn.areSomeValuesInArray(n[0], ["w", "n", "W", "N"]) && (t.resource = "entry", t.content = n[1]), !t.resource || "entry_comment" == t.resource) { const n = getUsernamesArrayFromText(t.content, !0); if (n.length > 0) { const s = getNewestMessageOfUser(e, n[0]); s ? (t.resource = "entry_comment", t.entry_id = s.entry_id) : t.resource = "entry" } } if (t.resource || (t.resource = "entry"), "entry" != t.resource || t.content.includes(`#${e.name}`) || (t.content += ` #${e.name}`), "WykopX" === user.username && (settings.promoFooter.roomInfo = !0, settings.promoFooter.mikroczatLinks = !0), t.content += "\n\n---\n", settings.promoFooter.roomInfo) { let n = getNumberOfOnlineUsersOnChannel(e); const s = n % 10; 2 !== s && s % 10 != 3 && s % 10 != 4 || (n += 3), t.content += ` ðŸŸ¢ ${n} osÃ³b online na kanale [**#${e.name}**](https://mikroczat.pl/czat/${e.name}) \n` } return (settings.promoFooter.emoji || settings.promoFooter.label) && (t.content += " [", settings.promoFooter.emoji && (t.content += "ðŸ’­"), settings.promoFooter.emoji && settings.promoFooter.label && (t.content += " "), settings.promoFooter.label && (t.content += "Mikro**czat**"), t.content += `](https://mikroczat.pl/czat/${e.name})`), settings.promoFooter.mikroczatLinks && (t.content += " | [ðŸ“˜ Instrukcja](https://github.com/wykopx/WykopX/wiki/MikroCzat) ", t.content += " | [ðŸ§· Skrypt logowania na Mikroczat](https://greasyfork.org/pl/scripts/489949-wykop-xs-mikroczat) "), new T.Entry(t, e) } function highlight(e, t) { fn.addClass(e, t) } function unhighlight(e, t) { fn.removeClass(e, t) } function setupScrollListener(e) { e && e.addEventListener("scroll", (function () { Math.abs(e.scrollTop) < e.clientHeight ? "0" === e.dataset.scrollToNew && (e.dataset.scrollToNew = "1") : "1" === e.dataset.scrollToNew && (e.dataset.scrollToNew = "0") }), !1) } document.addEventListener("visibilitychange", (function () { "visible" === document.visibilityState ? activeChannels[0] && "loaded" == activeChannels[0].loadingStatus && (activeChannels[0].unreadMessagesCount = 0, activeChannels[0].unreadMentionsCount = 0, window.top.document.title = getTabTitle(activeChannels[0])) : document.visibilityState })), Split({ columnGutters: [{ track: 1, element: document.querySelector(".gutter-column-1") }, { track: 3, element: document.querySelector(".gutter-column-3") }], rowGutters: [{ track: 1, element: document.querySelector(".gutter-row-1") }, { track: 3, element: document.querySelector(".gutter-row-3") }] }), window.opener && window.opener.postMessage("MikroCzatOpened", "https://wykop.pl"), window.addEventListener("message", (function (e) { if (e.origin === wykopDomain && e?.data?.type) { switch (e.data.type) { case "token": e.data.token && api.saveToken({ tokenValue: e.data.token, tokenType: "token" }); break; case "userKeep": e.data.userKeep && api.saveToken({ tokenValue: e.data.userKeep, tokenType: "userKeep" }); break; case "TokensObject": e.data.token && api.saveToken({ tokenValue: e.data.token, tokenType: "token" }), e.data.userKeep && api.saveToken({ tokenValue: e.data.userKeep, tokenType: "userKeep" }); break; case "nightMode": toggleNightMode(e.data.value); break; default: return !1 }mikroczatLoggedIn || logIn() } }), !1), window.logout = function () { tokensObject = null, window.sessionStorage.setItem("mikroczatLoggedOut", "true"), window.localStorage.removeItem("token"), window.localStorage.removeItem("userKeep"), settings.sounds.logged_out && navigator?.userActivation?.hasBeenActive && sounds.logged_out.play(), alert("Wylogowano z MikroCzata"), window.close(), window.location.reload() }, window.youtubeswitch = function () { "tr" == main.dataset.youtubePlayer ? main.dataset.youtubePlayer = "cl" : "hidden" == main.dataset.youtubePlayer ? main.dataset.youtubePlayer = "tr" : main.dataset.youtubePlayer = "hidden" }, window.spotifyswitch = function () { "tc" == main.dataset.spotifyPlayer && "tr" != main.dataset.youtubePlayer ? main.dataset.spotifyPlayer = "tr" : "hidden" == main.dataset.spotifyPlayer ? main.dataset.spotifyPlayer = "tc" : main.dataset.spotifyPlayer = "hidden" }, window.activateChannel = async function (e) { "string" == typeof e && (e = openedChannels.has(e) ? openedChannels.get(e) : new T.Channel(new T.Tag(e))); let t = mikrochatFeeds.querySelector(`.channelFeed[data-channel="${e.name}"]`); if (t || (t = (e = await openNewChannel(e)).elements.channelFeed), t) { activeChannels[0] = openedChannels.get(e.name), window.top.document.title = `${e.name} ${CONST.tabTitleTemplate}`; const n = mikrochatFeeds.querySelector('.channelFeed[data-active="true"]'); n && (n.dataset.active = "false"), t.dataset.active = "true", activeChannels[0].elements.messagesContainer.scrollTop = activeChannels[0].elements.messagesContainer.scrollHeight, e.tag?.media?.photo?.url ? centerHeader.style.backgroundImage = `url(${e.tag?.media?.photo?.url})` : centerHeader.style.backgroundImage = "unset" } history.pushState(null, null, `/${$folder}/${e.name}`) }, window.onload = function () { toggleNightMode(nightMode) }, hotChannels && hotChannels.length > 0 && chooseChannelDialog && hotChannels.forEach((e => { chooseChannelDialog.querySelector(`#${e}`).classList.add("hotChannel") })), document.addEventListener("DOMContentLoaded", (e => { if (window.innerWidth < 768) return document.querySelector("#mobileInfo").showModal(), !0; document.querySelector("#showChannelDialogButton").addEventListener("click", (function (e) { chooseChannelDialog.showModal() })), document.querySelector("#closeChannelDialogButton").addEventListener("click", (function (e) { chooseChannelDialog.close() })), document.body.addEventListener("mouseover", (function (e) { if (settings.highlightQuick) { let t = e.target.closest(".messageArticle[data-entry-id]"); !t || t.classList.contains("highlightLock") || t.classList.contains("highlightQuick") || (t.classList.contains("comment") ? (t.classList.add("highlightQuick"), highlight(`.messageArticle.entry[data-id="${t.dataset.entryId}"]`, "highlightQuick"), mouseOutAddEventListenerRemoveHighlightQuick(t)) : t.classList.contains("entry") && "0" != t.dataset.commentsCount && (t.classList.add("highlightQuick"), highlight(`.messageArticle.comment[data-entry-id="${t.dataset.entryId}"]`, "highlightQuick"), mouseOutAddEventListenerRemoveHighlightQuick(t))) } })), document.body.addEventListener("contextmenu", (function (e) { if (!settings.rightClickOnUsernameShowContextMenu) { let t = e.target.closest("a.username"); t && t.dataset.username && e.preventDefault() } })), document.body.addEventListener("mousedown", (function (e) { if ((settings.rightClickOnUsernameCopiesToClipboard || settings.rightClickOnUsernameInsertsToNewMessage) && (e.shiftKey || e.ctrlKey || e.altKey || 2 === e.button)) { settings.rightClickOnUsernameInsertsToNewMessage && e.preventDefault(); let s = e.target.closest("a.username"); if (s && s.dataset.username) { const e = `@${s.dataset.username}`; if (settings.rightClickOnUsernameCopiesToClipboard && navigator.clipboard.writeText(e).then((() => { })).catch((e => { })), settings.rightClickOnUsernameInsertsToNewMessage) { const a = openedChannels.get(s.dataset.channel).elements.newMessageTextarea; if (a) { a.innerText = a.innerText.trimEnd() + " " + e + " ", a.focus(); var t = document.createRange(), n = window.getSelection(); t.setStart(a.childNodes[0], a.innerText.length), t.collapse(!0), n.removeAllRanges(), n.addRange(t) } } } } })), document.body.addEventListener("dblclick", (function (e) { if (settings.highlightLock) { let t = e.target.closest(".messageArticle[data-entry-id]"); t && (t.classList.contains("highlightLock") ? (fn.removeClass(".messageArticle.highlightedItem", "highlightedItem"), unhighlight(`.messageArticle[data-entry-id="${t.dataset.entryId}"]`, "highlightLock")) : (t.classList.add("highlightedItem"), highlight(`.messageArticle[data-entry-id="${t.dataset.entryId}"]`, "highlightLock"))) } })), document.body.addEventListener("click", (async function (e) { let t = e.target; if ("BUTTON" === t.tagName && t.classList.contains("loadOlderMessagesButton")) { const e = t.closest(".channelFeed").dataset.channel, n = openedChannels.get(e); if (t.closest("button.loadOlderMessagesButton")) { let e = await api.getXNewestEntriesFromChannelFromPageHash(n, n.pagination.next, settings.fetch.numbersOfEntriesToLoadInChannel); if (e.length > 0) { analyzeMessagesArrayAddNewItemsOrUpdateDataExistingMessages(n, e); for (let t of e) t.comments.count > 0 && await checkAndInsertNewCommentsInEntry(n, t) } return !0 } } if (settings.newMessageSendButton && "BUTTON" === t.tagName && t.classList.contains("newMessageSendButton")) { const n = t.dataset.channel, s = openedChannels.get(n), a = t.previousElementSibling; if (n && a) { e.preventDefault(); let t = await api.postNewMessageToChannel(s, prepareNewMessageBody(s, { content: a.innerText })); return t && (insertNewItem(s, t), a.innerText = ""), !0 } } if (settings.leftClickOnYouTubeLoadsToIframe && "A" === t.tagName && t.classList.contains("entryMediaEmbedYouTube")) { e.preventDefault(); let n = fn.getEmbedVideoIDCodeFromYouTubeURL(t.href); return n && "string" == typeof n && (youtubeIframe.src = `https://www.youtube.com/embed/${n}?autoplay=1&mute=0`), !0 } return !1 })), document.body.addEventListener("keydown", (async function (e) { const t = e.target; if (settings.editorSendHotkey.enter && "Enter" === e.key || settings.editorSendHotkey.ctrl_enter && e.ctrlKey && "Enter" === e.key || settings.editorSendHotkey.ctrl_s && e.ctrlKey && "s" === e.key) { const n = t.closest(".newMessageTextarea"); if (n) { const t = n.dataset.channel, s = openedChannels.get(t); return e.preventDefault(), insertNewItem(s, await api.postNewMessageToChannel(s, prepareNewMessageBody(s, { content: n.innerText }))), void (n.innerText = "") } } })) })), function () { if (settings.css) for (const e in settings.css) { const t = document.getElementById(e); if (t) for (const n in settings.css[e]) t.dataset[n] = settings.css[e][n] } }();