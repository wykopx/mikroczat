"use strict"; import *as api from "./wykop_api.js"; import *as CONST from "./const.js"; import *as T from "./types.js"; import *as fn from "./fn.js"; const openedChannels = new Map, activeChannels = [null, null]; let mikroczatLoggedIn = !1, wykopDomain = "https://wykop.pl", wxDomain = "https://wykopx.pl", mikroczatDomain = "https://wykopx.pl"; const root = document.documentElement, head = document.head, body = document.body, main = document.getElementById("main"), chatArea = document.getElementById("chatArea"), newMessageSound = new Audio("/_sounds/switch-7.wav"); let user = { username: "Anonim (Ty)" }; export let tokensObject = api.getTokenFromDatabase(); let nightMode = localStorage.getItem("nightMode"); !tokensObject.token && !tokensObject.refresh_token || mikroczatLoggedIn || logIn(); const template_channelFeed = document.getElementById("template_channelFeed"), template_messageArticle = document.getElementById("template_messageArticle"), mikrochatFeeds = document.getElementById("mikrochatFeeds"), numbersOfEntriesToLoadOnChannelOpen = 30, numbersOfEntriesToCheck = 2, numbersOfCommentsToLoad = 20; var intervalID = setInterval((function () { }), 1e4); const loginDialog = document.querySelector("#loginDialog"), loginInput = document.querySelector("#loginInput"), loginAlertTokenSuccess = document.querySelector("#loginDialog #loggedInToken"), loginAlertRefreshTokenSuccess = document.querySelector("#loginDialog #loggedInRefreshToken"), loginAlertError = document.querySelector("#loginDialog .alert-error"), showLoginDialogButton = document.querySelector("#showLoginDialog"), closeLoginDialogButton = document.querySelector("#closeLoginDialogButton"); function processLoginData(e) { if ("" == e || null == e || null == e) return !1; if (e.length < 64) return fn.hide(loginAlertRefreshTokenSuccess), fn.hide(loginAlertTokenSuccess), fn.show(loginAlertError), !1; let t = api.saveToken({ tokenValue: e }); return !1 === t ? (fn.hide(loginAlertRefreshTokenSuccess), fn.hide(loginAlertTokenSuccess), fn.show(loginAlertError), !1) : (fn.hide(loginAlertError), "refreshToken" in t ? (fn.show(loginAlertRefreshTokenSuccess), !0) : "token" in t ? (fn.show(loginAlertTokenSuccess), !0) : void 0) } async function logIn() { if (tokensObject.refresh_token) { let e = await api.fetchAPIrefreshTokens(); !1 !== e && "object" == typeof e && "token" in e && (tokensObject.token = e.token) } tokensObject.token || (tokensObject = api.getTokenFromDatabase()), await fetch(`${CONST.apiPrefixURL}/profile/short`, { method: "GET", headers: { "Content-Type": "application/json", Authorization: "Bearer " + window.localStorage.getItem("token") } }).then((async e => e.ok ? e.json() : (mikroczatLoggedIn = !1, await api.fetchAPIrefreshTokens(), !1))).then((e => (user = e.data, confirmLoggedIn(), !0))).catch((e => { mikroczatLoggedIn = !1, loginDialog.showModal(), TypeError })) } async function confirmLoggedIn() { if (mikroczatLoggedIn = !0, fn.innerHTML(".loggedInUsername", user.username), window.opener && window.opener.postMessage("mikroczatLoggedInIn", wykopDomain), openChannelsFromURLArray.length > 0) for (const e of openChannelsFromURLArray) { const t = new T.Tag(e), n = new T.Channel(t); openedChannels.set(e, n) } if (openedChannels.size > 0) for (let [, e] of openedChannels) await e.tag.initFromAPI(), openNewChannel(e), e.users.set(user.username, user), window.activateChannel(e.name), await new Promise((e => setTimeout(e, 7e3))) } async function openNewChannel(e) { await e.tag.initFromAPI().then((() => { openedChannels.set(e.name, e) })); const t = template_channelFeed.content.cloneNode(!0), n = t.querySelector(".channelFeed"); n.dataset.channel = `channel_${e.name}`, n.id = `channel_${e.name}`, mikrochatFeeds.appendChild(t), openedChannels.get(e.name).element = document.getElementById(`channel_${e.name}`); const o = await api.getEntriesFromChannel(e, numbersOfEntriesToLoadOnChannelOpen); for (const t of o) e.users.set(t.author.username, t.author), insertNewMessage(t, e); return setCheckingForNewMessagesInChannel(e), e } async function setCheckingForNewMessagesInChannel(e, t = 6e3) { checkForNewMessagesInChannel(e), checkForNewCommentsInChannel(e); let n = null; n = setTimeout((function () { setTimeout(setCheckingForNewMessagesInChannel, t + Math.floor(2501 * Math.random()) + 500, e) }), t) } async function checkForNewMessagesInChannel(e) { const t = (await api.getEntriesFromChannel(e, numbersOfEntriesToCheck)).filter((t => !e.entries.has(t.id))); for (const n of t) e.users.set(n.author.username, n.author), insertNewMessage(n, e) } async function checkForNewCommentsInChannel(e) { for (const [t, n] of e.entries) { const n = await api.getCommentsFromEntryFromPage(t, numbersOfCommentsToLoad); for (const t of n) e.users.set(t.author.username, t.author), insertNewMessage(t, e) } } function closeChannel(e) { openedChannels.delete(e.name) } function closeActiveChannel() { } function getYouTubeFromChannel(e) { const t = openedChannels.get(e.name); let n = null, o = -1 / 0; return t.entries.forEach((e => { e.media?.embed && e.votes.up > o && (o = e.votes.up, n = e) })), n } async function insertNewMessage(e, t) { const n = openedChannels.get(t.name); if (n.entries.has(e.id)) return !1; navigator?.userActivation?.hasBeenActive && newMessageSound.play(), n.element.append(getMessageHTMLElement(e)), n.addEntry(e.id, e) } function getMessageHTMLElement(e) { const t = template_messageArticle.content.cloneNode(!0), n = t.querySelector(".messageArticle"); n.id = `${e.resource}-${String(e.id)}`, n.dataset.id = String(e.id), n.dataset.entryId = String(e.entry_id), n.dataset.authorUsername = e.author?.username, n.style.order = `-${e.created_at_Timestamp}`, e.author?.username === e.channel?.tag?.author?.username && n.classList.add("channelOwner"); t.querySelector(".entryDate").title = `${e.created_at_Format("eeee BBBB")} | ${e.created_at_FormatDistanceSuffix} \n${e.created_at_Format("yyyy-MM-dd 'o godz.' HH:mm ")}`; const o = t.querySelector(".permalinkHref"); "entry" === e.resource ? (n.classList.add("entry"), o.setAttribute("href", `https://go.wykopx.pl/w${e.entry_id}`)) : "entry_comment" === e.resource && (n.classList.add("comment", "reply"), n.classList.add("comment"), o.setAttribute("href", `https://go.wykopx.pl/w${e.entry_id}k${e.id}`)); t.querySelector(".entryDateYYYMMDD").textContent = e.created_at_Format("yyyy-MM-dd"); t.querySelector(".entryDateHHMM").textContent = e.created_at_Format("HH:mm"); if (t.querySelector(".entryDateHHMMSS").textContent = e.created_at_Format("HH:mm:ss"), e.author.avatar) { t.querySelector(".avatar_img").setAttribute("src", e.author.avatar) } const a = t.querySelector("a.username"); a.setAttribute("href", `https://go.wykopx.pl/@${e.author.username}`), n.classList.add(e.author?.status), a.classList.add(e.author?.status), e.author?.color?.name && (n.classList.add(`${e.author?.color?.name}-profile`), a.classList.add(`${e.author?.color?.name}-profile`)), "m" == e.author?.gender ? (n.classList.add("male", "m-gender"), a.classList.add("male", "m-gender")) : "f" == e.author?.gender ? (n.classList.add("female", "f-gender"), a.classList.add("female", "f-gender")) : (n.classList.add("null-gender"), a.classList.add("null-gender")); t.querySelector(".username_span").textContent = e.author.username; return t.querySelector(".messageContent").innerHTML = e.content_parsed(), t } function toggleNightMode(e = !0) { "1" == e || 1 == e ? e = !0 : "0" != e && 0 != e || (e = !1), 0 == e || "1" == body.dataset.nightMode ? (body.dataset.nightMode = "0", nightMode = "0") : (body.dataset.nightMode = "1", nightMode = "1"), localStorage.setItem("nightMode", nightMode) } let timer; showLoginDialogButton.addEventListener("click", (() => { loginDialog.showModal() })), closeLoginDialogButton.addEventListener("click", (() => { processLoginData(loginInput.value) && logIn(), loginDialog.close() })), loginInput.addEventListener("paste", (e => { processLoginData(e.target.value) })), loginInput.addEventListener("change", (e => { processLoginData(e.target.value) })), loginInput.addEventListener("input", (e => { processLoginData(e.target.value) })), Split({ columnGutters: [{ track: 1, element: document.querySelector(".gutter-column-1") }, { track: 3, element: document.querySelector(".gutter-column-3") }], rowGutters: [{ track: 1, element: document.querySelector(".gutter-row-1") }, { track: 3, element: document.querySelector(".gutter-row-3") }] }), window.opener && window.opener.postMessage("MikroCzatOpened", "https://wykop.pl"), window.addEventListener("message", (function (e) { if (e.origin === wykopDomain && e?.data?.type) { switch (e.data.type) { case "token": e.data.token && !window.sessionStorage.getItem("mikroczatLoggedOut") && api.saveToken({ tokenValue: e.data.token, tokenType: "token" }); break; case "userKeep": e.data.userKeep && !window.sessionStorage.getItem("mikroczatLoggedOut") && api.saveToken({ tokenValue: e.data.userKeep, tokenType: "userKeep" }); break; case "TokensObject": e.data.token && !window.sessionStorage.getItem("mikroczatLoggedOut") && api.saveToken({ tokenValue: e.data.token, tokenType: "token" }), e.data.userKeep && !window.sessionStorage.getItem("mikroczatLoggedOut") && api.saveToken({ tokenValue: e.data.userKeep, tokenType: "userKeep" }); break; case "nightMode": toggleNightMode(e.data.value); break; default: return !1 }mikroczatLoggedIn || logIn() } }), !1), window.logout = function () { tokensObject = null, window.sessionStorage.setItem("mikroczatLoggedOut", "true"), window.localStorage.removeItem("token"), window.localStorage.removeItem("userKeep"), alert("Wylogowano z MikroCzata"), window.location.reload() }, window.youtubeswitch = function () { "tr" == main.dataset.youtubePlayer ? main.dataset.youtubePlayer = "cl" : "hidden" == main.dataset.youtubePlayer ? main.dataset.youtubePlayer = "tr" : main.dataset.youtubePlayer = "hidden" }, window.spotifyswitch = function () { "tc" == main.dataset.spotifyPlayer && "tr" != main.dataset.youtubePlayer ? main.dataset.spotifyPlayer = "tr" : "hidden" == main.dataset.spotifyPlayer ? main.dataset.spotifyPlayer = "tc" : main.dataset.spotifyPlayer = "hidden" }, window.activateChannel = async function (e) { "string" == typeof e && (e = new T.Channel(new T.Tag(e))); let t = body.querySelector(`.channelFeed[data-channel="channel_${e.name}"]`); if (t || (t = (e = await openNewChannel(e)).element), t) { const n = body.querySelector('.channelFeed[data-active="true"]'); if (n && n.dataset.channel === `channel_${e.name}`) return; n && (n.dataset.active = "false"), t.dataset.active = "true", activeChannels[0] = e } history.pushState(null, null, `/czat/${e.name}`) }, window.onload = function () { toggleNightMode(nightMode) }, document.addEventListener("DOMContentLoaded", (e => { document.body.addEventListener("click", (function (e) { let t = e.target.closest(".messageArticle[data-entry-id]"); var n; t && (t.classList.contains("highlightLock") ? (n = t.dataset.entryId, document.querySelectorAll(`article[data-entry-id="${n}"]`).forEach((e => { e.classList.remove("highlightLock") }))) : function (e) { let t = document.querySelectorAll(`article[data-entry-id="${e}"]`); t.forEach((e => { e.classList.add("highlightLock") })) }(t.dataset.entryId)) })) }));